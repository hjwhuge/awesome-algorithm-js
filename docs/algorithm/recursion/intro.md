### 递归

#### 使用递归要满足的三个条件

- 一个大问题可以拆分成若干个小问题解决
- 大问题与小问题除了数据规模不一致，求解思路完全一致
- 存在递归终止条件

#### 如何编写递归代码

写出地推公式，找出终止条件

> 找到通项公式，找到初始值

#### 递归代码要警惕重复计算

一些问题使用递归考虑，思路是非常清晰的，但是却不推荐使用递归，例如下面的几个问题：

- 斐波拉契数列
- 跳台阶

这几个问题使用递归都有一个共同的缺点，那就是包含大量的重复计算，如果递归层次比较深的话，直接会导致 JS 进程崩溃。

<img :src="$withBase('/斐波拉契数列.jpg')" alt="斐波拉契数列" />

你可以使用记忆化的方法来避免重复计算，即开辟一个额外空间来存储已经计算过的值，但是这样又会浪费一定的内存空间。因此上面的问题一般会使用动态规划求解。

> 所以，在使用递归之前，一定要判断代码是否含有重复计算，如果有的话，不推荐使用递归。

递归是一种思想，而非一个类型，很多经典算法都是以递归为基础，因此这里就不再给出更多问题。

#### 递归代码是否都可以改为迭代循环的非递归写法？

笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

### 递归公式

> 下面代码是伪代码

```js
function recursion(level, param1, param2, ...) {
  // 递归终止条件(必须要有)
  if (level > MIN_LEVEL) {
    print_result;
    return;
  }

  // 当前递归层级逻辑处理，如果需要
  process_data(level, data...);

  // 向下递归
  recursion(level - 1, newParam1, ...)

  // 如果需要,反转当前级别的状态
  reverse_state(level)
}
```

#### 简单递归示例-计算 n!

> n! = 1 \* 2 \* 3 \* ... \* n

```js
function factorial(n) {
  if (n >= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```
