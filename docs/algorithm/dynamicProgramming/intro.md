### 动态规划

动态规划其实可以理解为动态递推，由递归 + 记忆化推导得到。使用动态规划求解问题很重要的 3 点

- 最优子结构
  - 最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。
- 状态定义：opt[n], dn[n], fib[n]
  - eg: 斐波拉契数列中：opt[n], 走迷宫中：opt[i, j]
- 状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], ...)
  - 有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程
  - 状态转移方程是解决动态规划的关键
  - eg: 斐波拉契数列中：F(n) = F(n - 1) + F(n - 2)
  - eg: 走迷宫中，状态转移方程根据下一步是空地还是石头，执行不同操作

```js
if (a[(i, j)] === "空地") {
  opt[(i, j)] = opt[(i - 1, j)] + opt[(i, j - 1)];
} else {
  opt[(i, j)] = 0;
}
```

#### 可以应用动态规划求解问题的特点

- 求一个问题的最优解
  - 最优解（通常指求最大值或最小值）
- 整个问题的最优解是依赖各个子问题的最优解
- 把大问题分解成若干小问题，这些小问题之间还有相互重叠的更小的子问题
- 从上往下分析问题，从下往上求解问题
  - 为了避免求解重复子问题，我们可以采用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解

#### 处理重复子问题时

在处理重复子问题时，我们有两种方案

- 第一种是直接用回溯加记忆化的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。
- 第二种是使用动态规划的解决方法。

#### 示例

走迷宫，从 start 开始到 end，统计共有多少种走法，红色块表示是石头，每次只能往下或者往右走。

<img :src="$withBase('/dynamicProgramming.png')" alt="动态规划" />

自底向上的求解，可以帮你省略大量的复杂计算。
